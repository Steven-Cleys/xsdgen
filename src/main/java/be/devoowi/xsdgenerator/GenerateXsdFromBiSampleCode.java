package be.devoowi.xsdgenerator;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import org.apache.log4j.Logger;

enum Types {

    // Only define types that need overriding
    DATE("xsd:date", "xsd:dateTime");
//	DOUBLE("xsd:double", "xsd:double"),
//	STRING("xsd:string", "xsd:string"),
//	INTEGER("xsd:integer","xsd:integer"),
//	DECIMAL("xsd:decimal", "xsd:decimal");


    private String dateType;
    private String type;

    private Types(String dateType, String type) {
        this.dateType = dateType;
        this.type = type;
    }

    public static String getTypeForDataType(final String dataType) {
        for (Types t : Types.values()) {
            if (t.getDateType().equalsIgnoreCase(dataType))
                return t.getType();
        }
        return dataType;
    }

    public String getDateType() {
        return dateType;
    }

    public String getType() {
        return type;
    }
}

public class GenerateXsdFromBiSampleCode {

    private static final Logger logger = Logger.getLogger(GenerateXsdFromBiSampleCode.class.toString());
    private static String XSD_RESOURCE = "/xsd/FUSION_BI_CODE_SAMPLE.xsd";
    private static String XSD_COMMENT = "<!--Generated by RMC By the Code sample of BI -->";
    private static String XSD_HEADER = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + XSD_COMMENT + "\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" elementFormDefault=\"qualified\">";
    private static String XSD_FOOTER = "</xsd:schema>";
    private static String COMPLEX_MIXED_HEADER = "<xsd:complexType mixed=\"true\">";
    private static String COMPLEX_MIXED_FOOTER = "</xsd:complexType>";
    private String xsdresult;

    public static void main(String[] args) {
        GenerateXsdFromBiSampleCode gen = new GenerateXsdFromBiSampleCode();
        //gen.run();
    }

    public String run(String pathlocation) {

        Path p = Paths.get(pathlocation);
        logger.info("path " + p);
        FileVisitor<Path> fv = new SimpleFileVisitor<Path>() {
            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {

                if (file.toUri().toString().contains("DS_Store"))
                    return FileVisitResult.CONTINUE;
                logger.info("file" + file);
                logger.info("test logger");
                try {
                    if (cleanSampleCode(file)) {

//						String path = file.toFile() + ".xsd";
//						File f = new File(path);
//						System.out.println(path);
                        xsdresult = generateXSD(file);

                        Files.write(Paths.get(file.toFile() + ".xsd"), generateXSD(file).getBytes(), StandardOpenOption.CREATE_NEW);
                    }
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

                return FileVisitResult.CONTINUE;
            }
        };

        try {
            Files.walkFileTree(p, fv);
            return xsdresult;

        } catch (IOException e) {
            e.printStackTrace();
            return "File is invalid";
        }

    }

    private boolean cleanSampleCode(Path file) throws IOException {
        logger.info("cleanSampleCode");
        String[] remove = {"formatMask=\"\""};
        List<String> newLines = new ArrayList<String>();

        List<String> lines = Files.readAllLines(Paths.get(file.toUri()), StandardCharsets.UTF_8);
        for (String line : lines) {
            newLines.add(line.replace(remove[0], ""));
        }

        Files.write(Paths.get(file.toUri()), newLines, StandardCharsets.UTF_8);
        logger.info("cleanSampleCode" + file);
        return validateXML(file);

    }

    private boolean validateXML(Path file) throws IOException {
        logger.info("validateXML");
        try {
            File f = new File(file.toUri());
            logger.info("f " + f);
            SchemaFactory sf = SchemaFactory.newInstance(javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI);
            URL xsdURL = getClass().getResource("/XSD/FUSION_BI_CODE_SAMPLE.xsd");
            logger.info("xsdurl " + xsdURL);
            Source xmlFile = new StreamSource(f);
            Schema schema = sf.newSchema(xsdURL);
            logger.info("schema " + schema);
            Validator validator = schema.newValidator();
            validator.validate(xmlFile);
            logger.info("File is valid");
            logger.info("validateXML true");
            return true;
        } catch (SAXException se) {
            logger.info("validateXML SAXException");
            se.printStackTrace();
        } catch (IOException e) {
            logger.info("validateXML IOException");
            e.printStackTrace();
        }
        catch (Exception e) {
            logger.info("validateXML Exception " + e.toString());
            e.printStackTrace();
        }
        logger.info("validateXML false");
        return false;
    }

    private String generateXSD(Path file) throws Exception {
        File f = new File(file.toUri());
        StringBuffer sb = new StringBuffer();
        XPath xpath = XPathFactory.newInstance().newXPath();
        InputSource inputSource = new InputSource(new FileInputStream(f));

        String expression = "/output/nodeList/dataStructure";

        sb.append(XSD_HEADER).append("\n");

        NodeList dataStructures = (NodeList) xpath.evaluate(expression, inputSource, XPathConstants.NODESET);

        if (null != dataStructures && dataStructures.getLength() > 0) {

            for (int i = 0; i < dataStructures.getLength(); i++) {
                Node n = dataStructures.item(i);
                if (n.getNodeType() == Node.ELEMENT_NODE) {
                    sb.append("<xsd:element name=\"").append(((Element) n).getAttribute("tagName").toUpperCase()).append("\">")
                            .append("\n");
                    sb.append(COMPLEX_MIXED_HEADER).append("\n");
                }

                NodeList groups = n.getChildNodes();
                if (null != groups) {
                    sb.append("<xsd:sequence>").append("\n");

                    for (int e = 0; e < groups.getLength(); e++) {
                        Node node = groups.item(e);
                        if (node.getNodeType() == Node.ELEMENT_NODE) {
                            Element element = (Element) node;
                            sb.append("<xsd:element name=\"").append(element.getAttribute("name").toUpperCase())
                                    .append("\" minOccurs=\"0\" maxOccurs=\"unbounded\">").append("\n");
                            sb.append(COMPLEX_MIXED_HEADER).append("\n");
                            sb.append("<xsd:sequence>").append("\n");

                            NodeList items = node.getChildNodes();
                            for (int s = 0; s < items.getLength(); s++) {
                                Node item = items.item(s);

                                sb.append(addElement(item));
                            }

                            sb.append("</xsd:sequence>").append("\n");
                            sb.append(COMPLEX_MIXED_FOOTER).append("\n");
                            sb.append("</xsd:element>").append("\n");
                        }

                    }
                    sb.append("</xsd:sequence>").append("\n");
                }

                sb.append(COMPLEX_MIXED_FOOTER).append("\n");
                sb.append("</xsd:element>").append("\n");
            }
        }

        sb.append(XSD_FOOTER);
//		System.out.println(sb.toString());
        return sb.toString();
    }

    private String addElement(Node node) {
        StringBuffer sb = new StringBuffer();

        if (node.getNodeType() == Node.ELEMENT_NODE) {
            Element element = (Element) node;

            sb.append("<xsd:element name=\"").append(element.getAttribute("name")).append("\" minOccurs=\"0\" type=\"");
            sb.append(Types.getTypeForDataType(element.getAttribute("dataType")));
            sb.append("\"/>").append("\n");
        }
        return sb.toString();
    }

}